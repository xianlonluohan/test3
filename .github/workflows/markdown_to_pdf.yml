name: "Markdown to PDF Converter with Tiled Watermark"

on:
  push:
    branches: ["main", "master"]
    tags: ["v*", "pdf-*"]
  pull_request:
    branches: ["main", "master"]
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  convert-md-to-pdf:
    runs-on: ubuntu-latest
    
    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: "Install dependencies"
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pandoc \
            texlive-xetex \
            texlive-latex-extra \
            texlive-fonts-recommended \
            texlive-latex-recommended \
            texlive-lang-chinese \
            fonts-noto-cjk \
            fonts-noto-cjk-extra \
            fonts-wqy-microhei \
            fonts-wqy-zenhei \
            lmodern \
            tree \
            jq \
            python3-pip \
            poppler-utils \
            imagemagick
          
          pip3 install beautifulsoup4
      
      - name: "Prepare working directory"
        run: |
          # 创建所有必要的目录
          mkdir -p pdf_output
          mkdir -p temp_images
          
          # 收集所有图片到一个目录，方便pandoc查找
          echo "收集所有图片文件..."
          find . -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.gif" | head -50
      
      - name: "Create robust LaTeX template"
        run: |
          cat > header.tex << 'EOF'
          % 基本设置
          \documentclass[a4paper]{article}
          
          % 中文支持
          \usepackage{xeCJK}
          \usepackage[UTF8]{ctex}
          \setCJKmainfont{Noto Serif CJK SC}
          \setCJKsansfont{Noto Sans CJK SC}
          \setCJKmonofont{Noto Sans Mono CJK SC}
          
          % 页面设置
          \usepackage[margin=1in]{geometry}
          
          % 超链接
          \usepackage{hyperref}
          \hypersetup{
            colorlinks=true,
            linkcolor=blue,
            urlcolor=blue,
            citecolor=blue,
            pdfborder={0 0 0},
          }
          
          % 代码块
          \usepackage{listings}
          \usepackage{xcolor}
          
          \definecolor{codebg}{rgb}{0.98,0.98,0.98}
          \definecolor{framecolor}{rgb}{0.8,0.8,0.8}
          
          \lstset{
            basicstyle=\ttfamily\normalsize,
            backgroundcolor=\color{codebg},
            frame=single,
            framesep=6pt,
            framerule=0.8pt,
            rulecolor=\color{framecolor},
            breaklines=true,
            breakatwhitespace=false,
            breakautoindent=true,
            breakindent=0pt,
            postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
            showstringspaces=false,
            tabsize=2,
            numbers=none,
            xleftmargin=12pt,
            xrightmargin=12pt,
            upquote=true,
            columns=fullflexible,
            keepspaces=true,
          }
          
          % 图片处理
          \usepackage{graphicx}
          \usepackage{float}
          \usepackage{caption}
          
          % 表格优化
          \usepackage{tabularx}
          \usepackage{longtable}
          \usepackage{booktabs}
          \usepackage{array}
          
          % 设置表格字体更小
          \let\oldlongtable\longtable
          \let\endoldlongtable\endlongtable
          \renewenvironment{longtable}[1]{
            \footnotesize
            \setlength{\tabcolsep}{3pt}
            \renewcommand{\arraystretch}{1.0}
            \begin{oldlongtable}{#1}
          }{
            \end{oldlongtable}
          }
          
          % 段落设置
          \usepackage{parskip}
          \setlength{\parindent}{0pt}
          \setlength{\parskip}{0.8em}
          
          % 防止溢出
          \sloppy
          \setlength{\emergencystretch}{3em}
          
          % 水印
          \usepackage{eso-pic}
          \usepackage{tikz}
          \usetikzlibrary{calc}
          
          \newcommand\BackgroundPicture{%
            \begin{tikzpicture}[remember picture,overlay]
              \coordinate (page center) at (current page.center);
              \pgfmathsetmacro{\pagewidth}{\paperwidth}
              \pgfmathsetmacro{\pageheight}{\paperheight}
              
              \pgfmathsetmacro{\hcount}{3}
              \pgfmathsetmacro{\vcount}{5}
              \pgfmathsetmacro{\hspace}{\paperwidth/(\hcount+1)}
              \pgfmathsetmacro{\vspace}{\paperheight/(\vcount+1)}
              
              \foreach \i in {1,...,\hcount} {
                \foreach \j in {1,...,\vcount} {
                  \pgfmathsetmacro{\x}{-\paperwidth/2 + \i*\hspace}
                  \pgfmathsetmacro{\y}{-\paperheight/2 + \j*\vspace}
                  
                  \node at ($(page center) + (\x pt, \y pt)$) [
                    rotate=45,
                    scale=1.5,
                    text=gray!30,
                    opacity=0.4,
                    font=\sffamily\bfseries\small
                  ] {emakefun};
                }
              }
              
              \node at (page center) [
                rotate=45,
                scale=3,
                text=gray!30,
                opacity=0.6,
                font=\sffamily\bfseries
              ] {emakefun};
            \end{tikzpicture}%
          }
          
          \AddToShipoutPictureBG{\BackgroundPicture}
          
          % 图片路径设置
          \graphicspath{{./}{./picture/}{../picture/}{../../picture/}{../../../picture/}}
          
          % 图片宽度设置
          \makeatletter
          \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
          \makeatother
          
          % 页眉页脚
          \usepackage{fancyhdr}
          \pagestyle{fancy}
          \fancyhf{}
          \fancyfoot[C]{\thepage}
          \renewcommand{\headrulewidth}{0pt}
          \renewcommand{\footrulewidth}{0pt}
          
          % 防止标题重复
          \renewcommand{\sectionmark}[1]{}
          \renewcommand{\subsectionmark}[1]{}
          
          % 标题格式
          \usepackage{titlesec}
          \titleformat{\section}
            {\normalfont\Large\bfseries}
            {\thesection}
            {1em}
            {}
          
          \titleformat{\subsection}
            {\normalfont\large\bfseries}
            {\thesubsection}
            {1em}
            {}
          EOF
      
      - name: "Process Markdown files one by one"
        run: |
          # 创建日志目录
          mkdir -p conversion_logs
          
          # 查找所有Markdown文件
          MD_FILES=$(find . -name "*.md" -not -path "./.*" -not -path "*/node_modules/*" -not -path "./pdf_output/*" -not -path "./conversion_logs/*" | sort)
          
          total_count=0
          success_count=0
          fail_count=0
          
          echo "开始处理Markdown文件..."
          
          for md_file in $MD_FILES; do
            total_count=$((total_count + 1))
            
            echo ""
            echo "========================================"
            echo "处理文件 $total_count: $md_file"
            echo "========================================"
            
            # 获取目录和文件名
            dir_name=$(dirname "$md_file")
            base_name=$(basename "$md_file" .md)
            
            # 创建输出目录
            mkdir -p "pdf_output/$dir_name"
            
            # 检查文件是否存在
            if [ ! -f "$md_file" ]; then
              echo "文件不存在: $md_file"
              fail_count=$((fail_count + 1))
              continue
            fi
            
            # 备份原始文件
            cp "$md_file" "${md_file}.backup"
            
            # 创建临时文件，修复图片路径
            temp_md=$(mktemp)
            
            # 修复图片路径 - 使用sed处理所有可能的图片引用格式
            echo "修复图片路径..."
            
            # 方法1: 先复制图片到本地目录
            # 提取所有图片引用
            images=$(grep -o '!\[.*\]([^)]*)' "$md_file" | sed -e 's/.*](//' -e 's/)//' | grep -v '^http' || true)
            
            # 方法2: 使用更简单的sed替换
            # 创建临时文件进行处理
            cat "$md_file" > "$temp_md"
            
            # 尝试修复 ./picture/ 开头的路径
            sed -i 's|!\[\(.*\)\](\./picture/\(.*\))|![\1](picture/\2)|g' "$temp_md"
            
            # 尝试修复 picture/ 开头的路径（但没有./）
            sed -i 's|!\[\(.*\)\](picture/\(.*\))|![\1](picture/\2)|g' "$temp_md"
            
            # 尝试修复相对路径
            sed -i 's|!\[\(.*\)\](\.\./\(.*\))|![\1](../\2)|g' "$temp_md"
            
            # 构建资源路径 - 包括所有可能的目录
            resource_paths=".:$dir_name:$dir_name/picture:$(dirname "$dir_name")/picture:$(dirname "$(dirname "$dir_name")")/picture"
            
            # 添加绝对路径
            current_dir=$(pwd)
            resource_paths="$resource_paths:$current_dir:$current_dir/$dir_name:$current_dir/$dir_name/picture"
            
            echo "资源路径: $resource_paths"
            
            # 记录转换命令
            echo "开始转换..."
            
            # 使用pandoc转换
            set +e
            pandoc "$temp_md" \
              --resource-path="$resource_paths" \
              -o "pdf_output/$dir_name/$base_name.pdf" \
              --pdf-engine=xelatex \
              --listings \
              --include-in-header=header.tex \
              -V mainfont="Noto Serif CJK SC" \
              -V sansfont="Noto Sans CJK SC" \
              -V monofont="Noto Sans Mono CJK SC" \
              -V geometry:margin=1in \
              -V geometry:a4paper \
              -V colorlinks=true \
              -V linkcolor=blue \
              -V urlcolor=blue \
              --wrap=auto \
              --highlight-style=tango \
              -f markdown \
              --top-level-division=section \
              --variable tables \
              2>&1 | tee "conversion_logs/${base_name}_$(date +%s).log"
            
            conversion_status=$?
            set -e
            
            # 恢复备份
            mv "${md_file}.backup" "$md_file"
            
            # 检查转换结果
            if [ $conversion_status -eq 0 ] && [ -f "pdf_output/$dir_name/$base_name.pdf" ] && [ -s "pdf_output/$dir_name/$base_name.pdf" ]; then
              echo "✓ 成功转换: $md_file"
              success_count=$((success_count + 1))
              
              # 检查PDF文件
              pdf_size=$(du -h "pdf_output/$dir_name/$base_name.pdf" | cut -f1)
              echo "PDF大小: $pdf_size"
            else
              echo "✗ 转换失败: $md_file"
              fail_count=$((fail_count + 1))
              
              # 尝试使用简化的方法
              echo "尝试简化转换..."
              set +e
              pandoc "$md_file" \
                -o "pdf_output/$dir_name/${base_name}_simple.pdf" \
                --pdf-engine=xelatex \
                -V mainfont="Noto Serif CJK SC" \
                -V geometry:margin=1in \
                -V geometry:a4paper \
                2>&1 | tee -a "conversion_logs/${base_name}_simple_$(date +%s).log"
              
              if [ -f "pdf_output/$dir_name/${base_name}_simple.pdf" ] && [ -s "pdf_output/$dir_name/${base_name}_simple.pdf" ]; then
                echo "✓ 简化版转换成功"
                mv "pdf_output/$dir_name/${base_name}_simple.pdf" "pdf_output/$dir_name/$base_name.pdf"
                success_count=$((success_count + 1))
                fail_count=$((fail_count - 1))
              fi
              set -e
            fi
            
            # 清理临时文件
            rm -f "$temp_md"
            
            # 显示进度
            echo "进度: $success_count/$total_count 成功"
            
            # 避免CPU过载
            sleep 1
          done
          
          echo ""
          echo "========================================"
          echo "转换完成"
          echo "总计: $total_count 个文件"
          echo "成功: $success_count 个"
          echo "失败: $fail_count 个"
          echo "========================================"
          
          # 列出所有生成的PDF
          echo "生成的PDF文件:"
          find pdf_output -name "*.pdf" -type f | sort
      
      - name: "Check and fix PDF generation"
        run: |
          echo "检查PDF生成结果..."
          
          total_pdfs=$(find pdf_output -name "*.pdf" -type f 2>/dev/null | wc -l)
          
          if [ $total_pdfs -eq 0 ]; then
            echo "警告: 没有生成任何PDF文件!"
            echo "尝试最后的手段: 使用最基本的方法转换..."
            
            # 查找一个示例文件
            sample_file=$(find . -name "*.md" -not -path "./.*" -not -path "*/node_modules/*" | head -1)
            
            if [ -n "$sample_file" ]; then
              echo "找到示例文件: $sample_file"
              dir_name=$(dirname "$sample_file")
              base_name=$(basename "$sample_file" .md)
              
              mkdir -p "pdf_output/$dir_name"
              
              # 使用最基本的转换
              pandoc "$sample_file" \
                -o "pdf_output/$dir_name/$base_name.pdf" \
                --pdf-engine=xelatex \
                -V mainfont="Noto Serif CJK SC" \
                -V geometry:margin=1in
              
              if [ -f "pdf_output/$dir_name/$base_name.pdf" ]; then
                echo "示例文件转换成功"
              fi
            fi
          fi
          
          # 最终检查
          total_pdfs=$(find pdf_output -name "*.pdf" -type f 2>/dev/null | wc -l)
          echo "总共生成 $total_pdfs 个PDF文件"
          
          if [ $total_pdfs -eq 0 ]; then
            echo "错误: 没有PDF文件生成!"
            
            # 显示目录结构以帮助调试
            echo "当前目录结构:"
            find . -maxdepth 3 -type f -name "*.md" | head -20
            echo ""
            echo "Markdown文件总数:"
            find . -name "*.md" -not -path "./.*" -not -path "*/node_modules/*" | wc -l
            
            exit 1
          fi
      
      - name: "Copy resources to output"
        run: |
          echo "复制资源文件到输出目录..."
          
          # 复制resource目录
          find . -type d -name "resource" | while read resource_dir; do
            # 计算相对路径
            rel_path=$(echo "$resource_dir" | sed 's|^\./||')
            
            # 找到对应的输出目录
            pdf_dirs=$(find pdf_output -type f -name "*.pdf" | xargs dirname | sort -u)
            
            for pdf_dir in $pdf_dirs; do
              # 检查是否应该复制到这个目录
              if echo "$pdf_dir" | grep -q "${rel_path%/resource}"; then
                echo "复制 $resource_dir 到 $pdf_dir/"
                cp -r "$resource_dir" "$pdf_dir/" 2>/dev/null || true
              fi
            done
          done
      
      - name: "Create summary report"
        run: |
          echo "# PDF转换报告" > pdf_output/README.md
          echo "" >> pdf_output/README.md
          echo "生成时间: $(date '+%Y-%m-%d %H:%M:%S')" >> pdf_output/README.md
          echo "" >> pdf_output/README.md
          
          # 统计PDF文件
          pdf_files=$(find pdf_output -name "*.pdf" -type f | sort)
          pdf_count=$(echo "$pdf_files" | wc -l)
          
          echo "## 转换统计" >> pdf_output/README.md
          echo "" >> pdf_output/README.md
          echo "- 总PDF文件数: $pdf_count" >> pdf_output/README.md
          
          # 计算总大小
          total_size=0
          for pdf in $pdf_files; do
            size=$(stat -c%s "$pdf" 2>/dev/null || stat -f%z "$pdf" 2>/dev/null || echo "0")
            total_size=$((total_size + size))
          done
          
          total_size_mb=$((total_size / 1024 / 1024))
          echo "- 总大小: ${total_size_mb}MB" >> pdf_output/README.md
          
          echo "" >> pdf_output/README.md
          echo "## 文件列表" >> pdf_output/README.md
          echo "" >> pdf_output/README.md
          
          # 按目录分组
          declare -A dir_files
          
          for pdf in $pdf_files; do
            rel_path=${pdf#pdf_output/}
            dir_name=$(dirname "$rel_path")
            file_name=$(basename "$rel_path")
            file_size=$(du -h "$pdf" 2>/dev/null | cut -f1 || echo "未知")
            
            if [ "$dir_name" = "." ]; then
              dir_key="root"
            else
              dir_key="$dir_name"
            fi
            
            dir_files["$dir_key"]="${dir_files["$dir_key"]}- [$file_name]($rel_path) ($file_size)\n"
          done
          
          # 输出目录和文件
          for dir in "${!dir_files[@]}"; do
            if [ "$dir" = "root" ]; then
              echo "### 根目录" >> pdf_output/README.md
            else
              echo "### $dir/" >> pdf_output/README.md
            fi
            echo "" >> pdf_output/README.md
            echo -e "${dir_files[$dir]}" >> pdf_output/README.md
            echo "" >> pdf_output/README.md
          done
      
      - name: "Upload PDF artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: pdf-documents
          path: |
            pdf_output/
            conversion_logs/
          retention-days: 7
      
      - name: "Create release if tagged"
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          
          # 创建压缩包
          cd pdf_output
          zip -r "../pdf-documents-$TAG_NAME.zip" .
          cd ..
          
          # 上传到release
          gh release upload "$TAG_NAME" "pdf-documents-$TAG_NAME.zip" --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}